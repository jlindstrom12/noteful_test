<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <title>Note Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f4f4f4;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            width:90%
        }
        .controls {
            margin-bottom: 20px;
        }
        #chartContainer {
            width: 100%;
            height: 220px;  /* Increased from 100px */
            position: relative;
            /* border: 1px solid black; */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .info {
            display: flex;
            justify-content: space-between;
            width: 100vw;
            max-width: 650px;
            margin-top: 10px;
        }
        .info p {
            font-size: 16px;
            margin: 0;
        }
        /* #startButton {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        } */

        .mic-button {
            background-color: #ccc;
            height:120px;
            width: 120px;
            color: black;
            border: none;
            padding: 20px 24px;  /* Increased padding */
            border-radius: 12px;
            cursor: pointer;
            font-size: 50px;  /* Bigger icon size */
            transition: background-color 0.3s ease;
        }

        .mic-button:hover {
            background-color: #bbb;
        }

        .mic-button i {
            pointer-events: none;
        }

        /* Responsive design for mobile */
        @media (max-width: 650px) {
            .container {
                padding: 10px;
            }
            .info {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            #chartContainer {
                height: 100px;
            }
            #startButton {
                font-size: 16px;
                width: 100%;
                margin-top: 20px;
            }
        }

        .top-bar {
            width: 100%;
            height: 10px;
            background-color: #e0e0e0; /* light grey background */
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
        }

        h1{
            font-size:20px;
        }

        h2{
            font-size:50px;
            margin:0;
        }

        .top-bar-fill {
            width: 66%;
            height: 100%;
            background-color: #007bff; /* bootstrap blue */
        }

        .page-title {
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-top: 4px;      /* Reduced from default */
            margin-bottom: 8px;   /* Add some margin if needed */
            width: 100%;
        }

        .x-icon {
            color: #000; /* or whatever color you prefer */
        }

        .icons {
            display: flex;
            gap: 8px;
        }

        .icons .fa-heart {
            color: #ff4d4d;
        }

        .icons .fa-lightbulb {
            color: #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <div class="top-bar-fill"></div>
        </div>

        <div class="page-title">
            <div style = "display:flex; align-items: center; gap:16px;">
                <i class="fas fa-times x-icon"></i>
                <h1>Listen to the notes and repeat back to the microphone</h1>
            </div>
            <div style = "display:flex; align-items: center;">
                <span class="icons" style = "font-size:30px">
                
                <i class="fas fa-lightbulb"></i>
                <i class="fas fa-heart"></i>
                </span>
            </div>
        </div>
        <div style = "display:flex; width:100%; align-items:center;">
            <div class="soundControl">
                <button id="soundButton" class="mic-button">
                    <i class="fas fa-volume-up"></i>
                </button>
            </div>
            <img src="static/rickvanderzwet_Treble_clef_1.svg" alt="Treble Clef" width="100" height="200">
            <div>
                <h2>4</h2><br>
                <h2>4</h2>
            </div>
            <div id="chartContainer">
                <canvas id="noteChart"></canvas>
            </div>
        </div>

        <div class="info">
            <p style = "display:none;">Detected Frequency: <span id="frequency">0</span> Hz</p>
            <p style = "display:none;">Detected Note: <span id="note">None</span></p>
        </div>

        <div class="controls">
            <button id="startButton" class="mic-button">
              <i class="fas fa-microphone"></i>
            </button>
        </div>

        
    </div>

    <script>
        const startButton = document.getElementById('startButton');
        const frequencyDisplay = document.getElementById('frequency');
        const noteDisplay = document.getElementById('note');
        const canvas = document.getElementById('noteChart');
        const ctx = canvas.getContext('2d');

        let audioContext;
        let analyser;
        let microphone;
        let bufferLength;
        let dataArray;
        let isDetecting = false;

        let smoothedFrequency = 0;
        const SMOOTHING_FACTOR = 0.2;
        const MIN_FREQ = 293.66;
        const MAX_FREQ = 783.99;

        let frequencies = new Array(100).fill(0); // Stores past frequency values for the chart
        const frequencyToNoteMap = new Map([
                    ["D4", 10],  // C4 is approximately 261.63 Hz
                    ["D#4", 10], // C#4 is approxima
                    ["E4", 9], // C#4 is approxima
                    ["F4", 8], // C#4 is approxima
                    ["F#4", 8], // C#4 is approxima
                    ["G4", 7], // C#4 is approxima
                    ["G#4", 7], // C#4 is approxima
                    ["A4", 6], // C#4 is approxima
                    ["A#4", 6], // C#4 is approxima
                    ["B4", 5], // C#4 is approxima
                    ["C5", 4], // C#4 is approxima
                    ["C#5", 4], // C#4 is approxima
                    ["D", 3], // C#4 is approxima
                    ["D#5", 3], // C#4 is approxima
                    ["E5", 2], // C#4 is approxima
                    ["F5", 1], // C#4 is approxima
                    ["F#5", 1], // C#4 is approxima
                    ["G5", 0], // C#4 is approxima
            ])
        let notes = [ 5,6,7 ]
        let notesXY = []

        let currentX = 0; // Track the X position of the line
        let path = []; // Array to store the positions of the points

        clear()
        defineNotes(notes)
        drawNotes()

        startButton.addEventListener('click', async () => {
            if (!isDetecting) {
                path = []; // Array to store the positions of the points
                // startButton.innerHTML = "3"; // Start with 3
                startButton.style.background = '#ccc'; // Set background to default color
                clear()
                defineNotes(notes)
                drawNotes()
                let countdown = 1;
                const countdownInterval = setInterval(async() => {
                    startButton.innerHTML = countdown;
                    countdown++;

                    if(countdown % 2 == 0){
                        console.log("here")
                        startButton.style.background = "#FFBABA"
                    }
                    else{
                        startButton.style.background = "#CCC"
                    }
                    if (countdown > 6) {
                        clearInterval(countdownInterval); // Stop the countdown
                        startButton.innerHTML = `<i class="fas fa-microphone"></i>`; // Show microphone icon
                        startButton.style.background = '#BFD5FF'; // Change background to green
                        isDetecting = true;
                        await startNoteDetection();
                    }
                }, 1000); // Update every second

            } else {
                stopNoteDetection();
                startButton.style.background = '#ccc';                
                startButton.innerHTML = `<i class="fas fa-microphone"></i>`; // Show microphone icon again
                isDetecting = false;
                frequencyDisplay.textContent = '0';
                noteDisplay.textContent = 'None';
                frequencies.fill(0);
                path = []; // Array to store the positions of the points
                clear(); // Clear the chart
            }
        });


        async function startNoteDetection() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                microphone.connect(analyser);
                
                detectNote();
            } catch (err) {
                console.error("Error accessing audio:", err);
            }
        }

        function stopNoteDetection() {
            if (microphone) {
                microphone.disconnect();
            }
            if (audioContext && audioContext.state === 'running') {
                audioContext.close();
            }
        }

        function detectNote() {
            if (!isDetecting) return;

            analyser.getByteFrequencyData(dataArray);
           
            let maxIndex = 0;
            for (let i = 1; i < bufferLength; i++) {
                if (dataArray[i] > dataArray[maxIndex]) {
                    maxIndex = i;
                }
            }
            const sampleRate = audioContext.sampleRate;
            let frequency = maxIndex * sampleRate / analyser.fftSize;
            if(frequency <MIN_FREQ){
                frequency = MIN_FREQ+1;
            }
            if (frequency > MIN_FREQ) {
                // Apply smoothing
                smoothedFrequency = smoothedFrequency * (1 - SMOOTHING_FACTOR) + frequency * SMOOTHING_FACTOR;

                frequencyDisplay.textContent = smoothedFrequency.toFixed(2);
                noteDisplay.textContent = frequencyToNote(smoothedFrequency);

                // Update chart data
                frequencies.push(smoothedFrequency);
                if (frequencies.length > 100) {
                    frequencies.shift(); // Keep only the last 100 values
                }
                if(isDetecting == true){
                    drawChart();
                }
            }
            requestAnimationFrame(detectNote);
        }

        function frequencyToNote(frequency) {
            const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const A4 = 440;
            const semitone = 12;
            const noteNumber = Math.round(69 + semitone * Math.log2(frequency / A4));
            const octave = Math.floor(noteNumber / 12) - 1;
            const note = noteNames[noteNumber % 12];
            return `${note}${octave}`;
        }



        function drawChart() {
            if (!isDetecting) return;

            // Only clear if currentX hasn't reached the end
            if (currentX < canvas.width) {
                clear();  // Clear the canvas only when still drawing
            }

            let place = 0;
            for (let [noteName, noteplace] of frequencyToNoteMap) {
                if (noteName === frequencyToNote(smoothedFrequency)) {
                    place = noteplace;
                }
            }

            let y = (canvas.height / 11 * place) + canvas.height / 22;
            
            path.push({ x: currentX, y: y });

            // Draw the path so far
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            for (let i = 0; i < path.length - 1; i++) {
                ctx.moveTo(path[i].x, path[i].y);
                ctx.lineTo(path[i + 1].x, path[i + 1].y);
            }
            ctx.stroke();

            // Draw notes
            drawNotes();

            // Mark hits
            for (let j = 0; j < notesXY.length; j++) {
                let targetX = notesXY[j][0];
                let targetY = notesXY[j][1];
                if (targetX + 5 > currentX && currentX > targetX - 5) {
                    if (targetY + 10 > y && y > targetY - 10) {
                        console.log("hit");
                        notesXY[j][2] = 1; // Mark as hit
                    }
                }
            }

             // Draw the current point (red dot)
            // ctx.beginPath();
            // ctx.arc(currentX, y, 15, 0, 2 * Math.PI); // Draw a circle with a radius of 8.33 px
            // ctx.fillStyle = "red";
            // ctx.fill();

            // Move the X position forward only if still scrolling
            if (currentX < canvas.width) {
                currentX += 1; // You can adjust this speed
            }
            else{
                stopNoteDetection()
                startButton.style.background = '#ccc'; // Set background to default color
            }
        }

        function defineNotes(listOfYs) {
            const radius = 15;
            const width = canvas.width;
            const spacing = width / (listOfYs.length + 1); // Spacing between notes
            let note_y = 0;

            notesXY = []; // Reset the notesXY array

            listOfYs.forEach((y, i) => {
                const x = spacing * (i + 1); // X position for each note
                
                // Y position calculation
                if (y > 5) {
                    note_y = (canvas.height / 11 * y) + canvas.height / 22;
                } else {
                    note_y = (canvas.height / 11 * y) + canvas.height / 22;
                }

                // Initialize notesXY with x, y, and hit state (0 means not hit)
                notesXY.push([x, note_y, 0]); 
            });
        }

        function drawNotes() {
            const radius = 15; // radius for the note head
            const stemLength = 60; // length of the stem
            const width = canvas.width;
            const spacing = width / (notesXY.length + 1);
            
            notesXY.forEach((note, i) => {
                const x = spacing * (i + 1); // X-coordinate of the note
                const y = note[1]; // Y-coordinate of the note head
                const hit = note[2];  // Whether the note is hit (for coloring)
                
                // Set the fill color based on whether the note is hit
                ctx.fillStyle = hit === 1 ? "green" : "black";
                
                // Draw the note head (ellipse)
                ctx.beginPath();
                ctx.ellipse(x, y, radius, radius, 0, 0, Math.PI * 2); // Draw the ellipse for the note head
                ctx.fill();
                
                // Draw the stem
                ctx.beginPath();
                ctx.moveTo(x+radius, y);  // Start the stem from the bottom of the note head
                ctx.lineTo(x+radius, y - stemLength); // Extend the stem downward
                ctx.strokeStyle = hit === 1 ? "green" : "black";
                ctx.lineWidth = 2; // Stem width
                ctx.stroke();
            });
        }



        function clear() {
          
            canvas.width = canvas.clientWidth; // Adjust to container size
            canvas.height = canvas.clientHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawNotes(notes)
            // Draw staff lines
            ctx.strokeStyle = "#888";
            ctx.lineWidth = 1;
            for (let i = 1; i <= 5; i++) {
                let y = (canvas.height / 6) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            
        }

        // const notesX = [100, 200, 300]; // example values
        const threshold = 2; // pixels of tolerance
        const sound1 = new Audio("static/firstnote-B.m4a");
        const sound2 = new Audio("static/secondnote-A.m4a");
        const sound3 = new Audio("static/thirdnote-G.m4a");
        let hasPlayedAtX = {}; // to avoid playing the same note repeatedly
        let animationId = null;
        let lineX = 0;

        function drawMovingLine() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
            clear();

            // Draw vertical blue line
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lineX, 0);
            ctx.lineTo(lineX, canvas.height);
            ctx.stroke();

            // ðŸ”Š Check for hit
            notesXY.forEach(x => {
                if (Math.abs(lineX - x[0]+30) < threshold && !hasPlayedAtX[x[0]]) {
                    if(x == notesXY[0]){
                        sound1.paused; // reset sound to start
                        sound2.paused; // reset sound to start
                        sound3.paused; // reset sound to start
                        setTimeout(() => {
                            sound1.play();
                        }, 200); // Delay in milliseconds
                        hasPlayedAtX[x[0]] = true;
                    }
                    if(x == notesXY[1]){
                        sound1.paused; // reset sound to start
                        sound2.paused; // reset sound to start
                        sound3.paused; // reset sound to start
                        setTimeout(() => {
                            sound2.play();
                        }, 200); // Delay in milliseconds
                        hasPlayedAtX[x[0]] = true;
                    }
                    if(x == notesXY[2]){
                        sound1.paused; // reset sound to start
                        sound2.paused; // reset sound to start
                        sound3.paused; // reset sound to start
                        setTimeout(() => {
                            sound3.play();
                        }, 200); // Delay in milliseconds
                        hasPlayedAtX[x[0]] = true;
                    }
                }
                   
            });

            // Move line to the right
            lineX += 2;

            // Wrap around if it reaches the end
            if (lineX > canvas.width) {
                clear();
                // lineX = 0;
                // hasPlayedAtX = {}; // reset for a new loop
            }

            // Keep animating
            animationId = requestAnimationFrame(drawMovingLine);
        }

        document.getElementById("soundButton").addEventListener("click", () => {
            if (animationId === null) {
                drawMovingLine(); // Start animation
            }
        });
    </script>
</body>
</html>
